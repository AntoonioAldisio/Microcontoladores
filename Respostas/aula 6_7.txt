

Para cada questão, escreva funções em C e/ou sub-rotinas na linguagem Assembly do MSP430. Reaproveite funções e sub-rotinas de uma questão em outra, se assim desejar. Leve em consideração que as sub-rotinas são utilizadas em um código maior, portanto utilize adequadamente os registradores R4 a R11. As instruções da linguagem Assembly do MSP430 se encontram ao final deste texto.

1. (a) Escreva uma função em C que calcule a raiz quadrada 'x' de uma variável 'S' do tipo float, utilizando o seguinte algoritmo: após 'n+1' iterações, a raiz quadrada de 'S' é dada por

	x(n+1) = (x(n) + S/x(n))/2

O protótipo da função é:

	
	unsigned int Raiz_Quadrada(unsigned int S);

	float x0 = S/2;
        float x;
        int n;
        for(n = 0; n <= interacoes; n++){
            x = (x0 + (S/x0))/2;
	    x0 = x;
}		

(b) Escreva a sub-rotina equivalente na linguagem Assembly do MSP430. A variável 'S' é fornecida pelo registrador R15, e a raiz quadrada de 'S' (ou seja, a variável 'x') é fornecida pelo registrador R15 também.

x0 = R13
S = R15

CalculaRaiz: add.w #1,R11    ; calcula div R15/R13 e guarda em R15 --> (R15 = R15/R13)
	     mov.w #0,R12    ; registrador que guarda o "resultado" primário para divisao  		
             mov.w R15,R14   ; copia R15(numerador) para R14(registrador temporario). 
	     cmp.w #0,R15	
	     jz fim	     ; se o numerador for Zero, a divisão termina

looping:     sub.w R13,R14;  ; R14 = R14-R13
             jn fimDiv	     ; se o valor de SUB R13,R14 for negativo então a divisão termina.
	     cmp.w R14,R15   ; se a divisão for por zero, essa comparação permite terminar a div.
	     jz fimDiv       ; 
	     add.w #1,R12    ; vai adicionando um valor ao resultado até o resultado final.
	     jmp looping     ; looping para somar repetidas vezes até R12 ser Zero.

fimDiv:    
			     ; ------------------------------------------------------- 
	     add.w R13,R12   ; R15 = Xo + (S/Xo)
	     rra.w R12	     ;       -----------
	     mov.w R12,R15   ;            2
	     sub.w #15,R11   ; analisa as 15 interações
	     jn Fim          ; FIM
	     jmp CalculaRaiz ; looping de interações
	
Fim ret ;

2. (a) Escreva uma função em C que calcule 'x' elevado à 'N'-ésima potência, seguindo o seguinte protótipo: 

	int Potencia(int x, int N);

Exercico resolvido na sala -----


(b) Escreva a sub-rotina equivalente na linguagem Assembly do MSP430. 'x' e 'n' são fornecidos através dos registradores R15 e R14, respectivamente, e a saída deverá ser fornecida no registrador R15.


Exercico resolvido na sala -----

3. Escreva uma sub-rotina na linguagem Assembly do MSP430 que calcula a divisão de 'a' por 'b', onde 'a', 'b' e o valor de saída são inteiros de 16 bits. 'a' e 'b' são fornecidos através dos registradores R15 e R14, respectivamente, e a saída deverá ser fornecida através do registrador R15.

Div: mov.w #0,R12
     mov.w R15,R13
     sub.w #0,R13
     jz Exit02

loop: sub.w R13,R14
      jn Exit
      inc.w R12;
      jmp loop

Exit02:	mov.w R12,R15
	ret

Exit:   mov.w #FFFFF.h, R15
	ret


4. Escreva uma sub-rotina na linguagem Assembly do MSP430 que calcula o resto da divisão de 'a' por 'b', onde 'a', 'b' e o valor de saída são inteiros de 16 bits. 'a' e 'b' são fornecidos através dos registradores R15 e R14, respectivamente, e a saída deverá ser fornecida através do registrador R15.

Calculo: mov.w R15,R13
	 mov.w R15,R11
	 sub.w #0, R13
	 jz Div; if dividir por zero, R15

loop: 	 mov.w R13,R11
	 sub.w R14,R13
	 jn Div
	 jmp loop

div:	 mov.w R11,R15
	 ret	



5. (a) Escreva uma função em C que indica a primalidade de uma variável inteira sem sinal, retornando o valor 1 se o número for primo, e 0, caso contrário. Siga o seguinte protótipo:

	int Primalidade(unsigned int x);
------------------------------------------	
	 printf("Digite um número inteiro e positivo: ");
    	 scanf("%d", &x);
While(x <=0){
	for(i=1; i<=x; i+++)
		if(x% i ==0)
		div++
}
if(div ==2)
% é primo
else
% não e primo
}

-----------------------------------------

for( x<=0; i++; i=1){
if ( x %= i == 0)
div++
 if(div ==2)
	return 1 ;
else 
	return 0;
}


(b) Escreva a sub-rotina equivalente na linguagem Assembly do MSP430. A variável de entrada é fornecida pelo registrador R15, e o valor de saída também.

		
Primalidade: mov.w #1, R14
	     clr.w R12

loop:	 push.w R15
	 call #Calc
	 inc.w R14
	 cmp #0, R15
	 jne condition
	 inc.w R12

condition: pop.w R15
	cmp.w R14,R15
	jn Exit
	jmp loop
Exit:	cmp #2,R12
	jeq vdd ; R15 =1;
	mov.w #0, R15
	jmp false
vdd: 	mov.w #1,R15
	 



6. Escreva uma função em C que calcula o duplo fatorial de n, representado por n!!. Se n for ímpar, n!! = 1*3*5*...*n, e se n for par, n!! = 2*4*6*...*n. Por exemplo, 9!! = 1*3*5*7*9 = 945 e 10!! = 2*4*6*8*10 = 3840. Além disso, 0!! = 1!! = 1.
O protótipo da função é:

	unsigned long long DuploFatorial(unsigned long long n);

7. (a) Escreva uma função em C que calcula a função exponencial da seguinte forma:
	
Considere o cálculo até o termo n = 20. O protótipo da função é double ExpTaylor(double x);

int main(){

//Definição de variaveis   
int i, vetorA[20], vetorB[20], aux=0;	  

//Entrada de dados
for(i=0; i<20; i++)
{
   printf("\n\n Informe o %d%c valor do Vetor A : ", i+1, 167);  
   scanf("%d", &vetorA[i]);  
}
for(i=0; i<20; i++)
{
   printf("\n\n Informe o %d%c valor do Vetor B : ", i+1, 167);  
   scanf("%d", &vetorB[i]);  
}
  
//Processamento	   
for(i=0; i<20; i++)
{	   
   aux += vetorA[i] * vetorB[i];
}


(b) Escreva a sub-rotina equivalente na linguagem Assembly do MSP430, mas considere que os valores de entrada e de saída são inteiros de 16 bits. A variável de entrada é fornecida pelo registrador R15, e o valor de saída também.

8. Escreva uma sub-rotina na linguagem Assembly do MSP430 que indica se um vetor esta ordenado de forma decrescente. Por exemplo:
[5 4 3 2 1] e [90 23 20 10] estão ordenados de forma decrescente.
[1 2 3 4 5] e [1 2 3 2] não estão.
O primeiro endereço do vetor é fornecido pelo registrador R15, e o tamanho do vetor é fornecido pelo registrador R14. A saída deverá ser fornecida no registrador R15, valendo 1 quando o vetor estiver ordenado de forma decrescente, e valendo 0 em caso contrário.

9. Escreva uma sub-rotina na linguagem Assembly do MSP430 que calcula o produto escalar de dois vetores, 'a' e 'b':
	
O primeiro endereço do vetor 'a' deverá ser passado através do registrador R15, o primeiro endereço do vetor 'b' deverá ser passado através do registrador R14, e o tamanho do vetor deverá ser passado pelo registrador R13. A saída deverá ser fornecida no registrador R15.

10. (a) Escreva uma função em C que indica se um vetor é palíndromo. Por exemplo:
	[1 2 3 2 1] e [0 10 20 20 10 0] são palíndromos.
	[5 4 3 2 1] e [1 2 3 2] não são.
Se o vetor for palíndromo, retorne o valor 1. Caso contrário, retorne o valor 0. O protótipo da função é:

	int Palindromo(int vetor[ ], int tamanho);

for (int i = 0; i < tamanho >> 1; i++)
	if (vetor[i] != vetor[tamanho - i - 1]) 
		return 0;
return 1;


(b) Escreva a sub-rotina equivalente na linguagem Assembly do MSP430. O endereço do vetor de entrada é dado pelo registrador R15, o tamanho do vetor é dado pelo registrador R14, e o resultado é dado pelo registrador R15.


int: clr.w  R15
     clr.w  R14
     mov.w #0(R15), R16
     mov.w #0(R14), R13	

loop: cmp #FFFFFh,R13
      jz palin
      mov.w R16,R13
      inc.w R13
      inc.w R16
      push R16
      jmp loop	
palin: cmp #0,							
	